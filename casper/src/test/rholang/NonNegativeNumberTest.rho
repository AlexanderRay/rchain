//scalapackage coop.rchain.rholang.math

//requires NonNegativeNumber, TestSet
new
  rl(`rho:registry:lookup`), RhoSpecCh, NonNegativeNumberCh,
  setup,
  test1, test2, test3, test4, test5, test6, test7
in {
  rl!(`rho:id:6wnujzcraztjfg941skrtbdkdgbko8nuaqihuhn15s66oz8ro5gwbb`, *RhoSpecCh) |
  rl!(`rho:id:nd74ztexkao5awjhj95e3octkza7tydwiy7euthnyrt5ihgi9rj495`, *NonNegativeNumberCh) |
  for(@(_, NonNegativeNumber) <- NonNegativeNumberCh;
      @(_, RhoSpec) <- RhoSpecCh) {

    contract setup(returnCh) = {
      returnCh!([])
    } |

    contract test1(rhoSpec, _, ackCh) = {
      new ch1, ch2, ch3 in {
        @NonNegativeNumber!(-1, *ch1) |
        for (v1 <- ch1) {
          v1!("value", *ch1) |
          rhoSpec!("assert", (0, "== <-", *ch1), "-1 is converted to 0", *ackCh)
        }
      }
    } |

    contract test2(rhoSpec, _, ackCh) = {
      new ch1, ch2 in {
        @NonNegativeNumber!(0, *ch1) |
        @NonNegativeNumber!(1, *ch2) |
        for (v1 <- ch1; v2 <- ch2) {
          v1!("value", *ch1) |
          v2!("value", *ch2) |
          rhoSpec!("assertMany",
            [
              ((0, "== <-", *ch1), "0 stays the same"),
              ((1, "== <-", *ch2), "1 stays the same"),
            ],
            *ackCh)
        }
      }
    } |

    contract test3(rhoSpec, _, ackCh) = {
      new ch, ch1, ch2 in {
        @NonNegativeNumber!(0, *ch) |
        for (v <- ch) {
          v!("add", -1, *ch1) |
          v!("sub", -1, *ch2) |
          rhoSpec!("assertMany",
            [
              ((false, "== <-", *ch1), "Adding a negative number fails"),
              ((false, "== <-", *ch2), "Subtracting a negative number fails"),
            ],
            *ackCh)
        }
      }
    } |

    contract test4(rhoSpec, _, ackCh) = {
      new ch in {
        @NonNegativeNumber!(0, *ch) |
        for (v <- ch) {
          v!("sub", 1, *ch) |
          rhoSpec!("assert", (false, "== <-", *ch), "subtracting fails", *ackCh)
        }
      }
    } |

    contract test5(rhoSpec, _, ackCh) = {
      new ch in {
        @NonNegativeNumber!(0, *ch) |
        for (nn <- ch) {
          nn!("add", 1, *ch) |
          for (@result <- ch) {
            nn!("value", *ch) |
            rhoSpec!("assertMany",
              [
                ((true, "==", result), "add succeeds"),
                ((1, "== <-", *ch), "result is correct"),
              ],
              *ackCh)
          }
        }
      }
    } |

    contract test6(rhoSpec, _, ackCh) = {
      new ch in {
        @NonNegativeNumber!(2, *ch) |
        for (nn <- ch) {
          nn!("sub", 1, *ch) |
          for (@result <- ch) {
            nn!("value", *ch) |
            rhoSpec!("assertMany",
              [
                ((true, "==", result), "sub succeeds"),
                ((1, "== <-", *ch), "result is correct"),
              ],
              *ackCh)
          }
        }
      }
    } |

    contract test7(rhoSpec, _, ackCh) = {
      new ch in {
        @NonNegativeNumber!(9223372036854775757, *ch) |
        for (nn <- ch) {
          nn!("add", 9223372036854775757, *ch) |
          rhoSpec!("assert", (false, "== <-", *ch), "add fails", *ackCh)
        }
      }
    } |

    @RhoSpec!("testSuite", *setup,
      [
        ("Initially negative balances are be converted to 0.", *test1),
        ("Positive initial balances are preserved.", *test2),
        ("Adding or subtracting a negative number fails.", *test3),
        ("Subtracting an amount larger than the balance fails.", *test4),
        ("Adding a positive number works if there's no overflow.", *test5),
        ("Subtracting a positive number less than or equal to the balance works", *test6),
        ("Addition overflow is prevented", *test7)
      ])
  }
}
